<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rezelchen.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="Storage and RetrievalWe will examine two families of storage engines: log-structured storage engines, and page-oriented storage engines such as B-trees. Data Structures That Power Your DatabaseHash In">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for DDIA in Chapter 3">
<meta property="og:url" content="https://rezelchen.github.io/2020/07/24/DDIA3/index.html">
<meta property="og:site_name" content="Ray Chen&#39;s Blog">
<meta property="og:description" content="Storage and RetrievalWe will examine two families of storage engines: log-structured storage engines, and page-oriented storage engines such as B-trees. Data Structures That Power Your DatabaseHash In">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-24T23:05:00.000Z">
<meta property="article:modified_time" content="2020-08-12T19:36:04.076Z">
<meta property="article:author" content="Ray Chen">
<meta property="article:tag" content="note">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rezelchen.github.io/2020/07/24/DDIA3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Note for DDIA in Chapter 3 | Ray Chen's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ray Chen's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Storage-and-Retrieval"><span class="nav-number">1.</span> <span class="nav-text">Storage and Retrieval</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Structures-That-Power-Your-Database"><span class="nav-number">1.1.</span> <span class="nav-text">Data Structures That Power Your Database</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash-Indexes"><span class="nav-number">1.1.1.</span> <span class="nav-text">Hash Indexes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSTables-and-LSM-Trees"><span class="nav-number">1.1.2.</span> <span class="nav-text">SSTables and LSM-Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Constructing-and-maintaining-SSTables"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Constructing and maintaining SSTables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Making-an-LSM-tree-out-of-SSTables"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">Making an LSM-tree out of SSTables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Performance-optimizations"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">Performance optimizations</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-Trees"><span class="nav-number">1.1.3.</span> <span class="nav-text">B-Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Making-B-trees-reliable"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Making B-trees reliable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-tree-optimizations"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">B-tree optimizations</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparing-B-Trees-and-LSM-Trees"><span class="nav-number">1.1.4.</span> <span class="nav-text">Comparing B-Trees and LSM-Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Advantages-of-LSM-trees"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">Advantages of LSM-trees</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Downsides-of-LSM-trees"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">Downsides of LSM-trees</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Other-Indexing-Structures"><span class="nav-number">1.1.5.</span> <span class="nav-text">Other Indexing Structures</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Storing-values-within-the-index"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">Storing values within the index</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Multi-column-indexes"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">Multi-column indexes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transaction-Processing-or-Analytics"><span class="nav-number">1.2.</span> <span class="nav-text">Transaction Processing or Analytics?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Data-Warehousing"><span class="nav-number">1.2.1.</span> <span class="nav-text">Data Warehousing</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#The-divergence-between-OLTP-databases-and-data-warehouses"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">The divergence between OLTP databases and data warehouses</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stars-and-Snowflakes-Schemas-for-Analytics"><span class="nav-number">1.2.2.</span> <span class="nav-text">Stars and Snowflakes: Schemas for Analytics</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Column-Oriented-Storage"><span class="nav-number">1.3.</span> <span class="nav-text">Column-Oriented Storage</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ray Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://rezelchen.github.io/2020/07/24/DDIA3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ray Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ray Chen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Note for DDIA in Chapter 3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-24 23:05:00" itemprop="dateCreated datePublished" datetime="2020-07-24T23:05:00+00:00">2020-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-12 19:36:04" itemprop="dateModified" datetime="2020-08-12T19:36:04+00:00">2020-08-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Storage-and-Retrieval"><a href="#Storage-and-Retrieval" class="headerlink" title="Storage and Retrieval"></a>Storage and Retrieval</h2><p>We will examine two families of storage engines: <em>log-structured</em> storage engines, and <em>page-oriented</em> storage engines such as B-trees.</p>
<h3 id="Data-Structures-That-Power-Your-Database"><a href="#Data-Structures-That-Power-Your-Database" class="headerlink" title="Data Structures That Power Your Database"></a>Data Structures That Power Your Database</h3><h4 id="Hash-Indexes"><a href="#Hash-Indexes" class="headerlink" title="Hash Indexes"></a>Hash Indexes</h4><p>Segments are never modified after they have been written, so the merged segment is written to a new file. The merging and compaction of frozen segments can be done in a background thread, and while it is going on, we can still continue to serve read and write requests as normal, using the old segment files. After the merging process is complete, we switch read requests to using the new merged segment instead of the old segments — and then the old segment files can simply be deleted.</p>
<p>Each segment now has its own in-memory hash table, mapping keys to file offsets. </p>
<p>An append-only design turns out to be good for several reasons:</p>
<ul>
<li><p>Appending and segment merging are sequential write operations, which are generally much faster than random writes, especially on magnetic spinning-disk hard drives.</p>
</li>
<li><p>Concurrency and crash recovery are much simpler if segment files are append-only or immutable.</p>
</li>
<li><p>Merging old segments avoids the problem of data files getting fragmented over time.</p>
</li>
</ul>
<p>The hash table index also has limitations:</p>
<ul>
<li>The hash table must fit in memory, so if you have a very large number of keys, you’re out of luck.</li>
<li>Range queries are not efficient. </li>
</ul>
<h4 id="SSTables-and-LSM-Trees"><a href="#SSTables-and-LSM-Trees" class="headerlink" title="SSTables and LSM-Trees"></a>SSTables and LSM-Trees</h4><p>SSTables have several big advantages over log segments with hash indexes:</p>
<ul>
<li><p>Merging segments is simple and efficient, even if the files are bigger than the available memory. The approach is like the one used in the <em>mergesort</em> algorithm</p>
</li>
<li><p>In order to find a particular key in the file, you no longer need to keep an index of all the keys in memory. You still need an in-memory index to tell you the offsets for some of the keys, but it can be sparse: one key for every few kilobytes of segment file is sufficient, because a few kilobytes can be scanned very quickly.i</p>
</li>
<li><p>Since read requests need to scan over several key-value pairs in the requested range anyway, it is possible to group those records into a block and compress it before writing it to disk. Each entry of the sparse in-memory index then points at the start of a compressed block.</p>
</li>
</ul>
<h5 id="Constructing-and-maintaining-SSTables"><a href="#Constructing-and-maintaining-SSTables" class="headerlink" title="Constructing and maintaining SSTables"></a>Constructing and maintaining SSTables</h5><ul>
<li><p>When a write comes in, add it to an in-memory balanced tree data structure (for<br>example, a red-black tree). This in-memory tree is sometimes called a memtable.</p>
</li>
<li><p>When the memtable gets bigger than some threshold—typically a few megabytes—write it out to disk as an SSTable file. This can be done efficiently because the tree already maintains the key-value pairs sorted by key. The new SSTable file becomes the most recent segment of the database. While the SSTable is being written out to disk, writes can continue to a new memtable instance.</p>
</li>
<li><p>In order to serve a read request, first try to find the key in the memtable, then in the most recent on-disk segment, then in the next-older segment, etc.</p>
</li>
<li><p>From time to time, run a merging and compaction process in the background to combine segment files and to discard overwritten or deleted values.</p>
</li>
</ul>
<p>This scheme works very well. It only suffers from one problem: if the database crashes, the most recent writes (which are in the memtable but not yet written out to disk) are lost. In order to avoid that problem, we can keep a separate log on disk to which every write is immediately appended, just like in the previous section. That log is not in sorted order, but that doesn’t matter, because its only purpose is to restore the memtable after a crash. Every time the memtable is written out to an SSTable, the corresponding log can be discarded.</p>
<h5 id="Making-an-LSM-tree-out-of-SSTables"><a href="#Making-an-LSM-tree-out-of-SSTables" class="headerlink" title="Making an LSM-tree out of SSTables"></a>Making an LSM-tree out of SSTables</h5><h5 id="Performance-optimizations"><a href="#Performance-optimizations" class="headerlink" title="Performance optimizations"></a>Performance optimizations</h5><p>The LSM-tree algorithm can be slow when looking up keys that do not exist in the database. In order to optimize this kind of access, storage engines often use additional <em>Bloom filters</em>.</p>
<p>There are also different strategies to determine the order and timing of how SSTables are compacted and merged. The most common options are <em>size-tiered</em> and <em>leveled</em> compaction.</p>
<h4 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B-Trees"></a>B-Trees</h4><p>Like SSTables, B-trees keep key-value pairs sorted by key, which allows efficient key- value lookups and range queries.</p>
<p>B-trees break the database down into fixed-size blocks or pages, traditionally 4 KB in size (sometimes bigger), and read or write one page at a time. </p>
<p>Each page can be identified using an address or location, which allows one page to refer to another—similar to a pointer, but on disk instead of in memory. </p>
<h5 id="Making-B-trees-reliable"><a href="#Making-B-trees-reliable" class="headerlink" title="Making B-trees reliable"></a>Making B-trees reliable</h5><p>In order to make the database resilient to crashes, it is common for B-tree implemen‐ tations to include an additional data structure on disk: a write-ahead log (WAL, also known as a redo log). </p>
<p>An additional complication of updating pages in place is that careful concurrency control is required if multiple threads are going to access the B-tree at the same time —otherwise a thread may see the tree in an inconsistent state. This is typically done by protecting the tree’s data structures with <em>latches</em> (lightweight locks).</p>
<h5 id="B-tree-optimizations"><a href="#B-tree-optimizations" class="headerlink" title="B-tree optimizations"></a>B-tree optimizations</h5><ul>
<li><p>Instead of overwriting pages and maintaining a WAL for crash recovery, some databases (like LMDB) use a copy-on-write scheme. A modified page is written to a different location, and a new version of the parent pages in the tree is created, pointing at the new location. </p>
</li>
<li><p>We can save space in pages by not storing the entire key, but abbreviating it.</p>
</li>
<li><p>If a query needs to scan over a large part of the key range in sorted order, that page-by-page layout can be ineffi‐ cient, because a disk seek may be required for every page that is read. Many B- tree implementations therefore try to lay out the tree so that leaf pages appear in sequential order on disk. </p>
</li>
<li><p>Additional pointers have been added to the tree. For example, each leaf page may have references to its sibling pages to the left and right, which allows scanning keys in order without jumping back to parent pages.</p>
</li>
<li><p>B-tree variants such as fractal trees borrow some log-structured ideas to reduce disk seeks (and they have nothing to do with fractals).</p>
</li>
</ul>
<h4 id="Comparing-B-Trees-and-LSM-Trees"><a href="#Comparing-B-Trees-and-LSM-Trees" class="headerlink" title="Comparing B-Trees and LSM-Trees"></a>Comparing B-Trees and LSM-Trees</h4><h5 id="Advantages-of-LSM-trees"><a href="#Advantages-of-LSM-trees" class="headerlink" title="Advantages of LSM-trees"></a>Advantages of LSM-trees</h5><p>LSM-trees are typically able to sustain higher write throughput than B- trees.</p>
<p>LSM-trees can be compressed better, and thus often produce smaller files on disk than B-trees. </p>
<h5 id="Downsides-of-LSM-trees"><a href="#Downsides-of-LSM-trees" class="headerlink" title="Downsides of LSM-trees"></a>Downsides of LSM-trees</h5><p>A downside of log-structured storage is that the compaction process can sometimes interfere with the performance of ongoing reads and writes. </p>
<p>Another issue with compaction arises at high write throughput: the disk’s finite write bandwidth needs to be shared between the initial write (logging and flushing a memtable to disk) and the compaction threads running in the background.</p>
<p>If write throughput is high and compaction is not configured carefully, it can happen that compaction cannot keep up with the rate of incoming writes.</p>
<p>An advantage of B-trees is that each key exists in exactly one place in the index, whereas a log-structured storage engine may have multiple copies of the same key in different segments. This aspect makes B-trees attractive in databases that want to offer strong transactional semantics: in many relational databases, transaction isola‐ tion is implemented using locks on ranges of keys, and in a B-tree index, those locks can be directly attached to the tree </p>
<h4 id="Other-Indexing-Structures"><a href="#Other-Indexing-Structures" class="headerlink" title="Other Indexing Structures"></a>Other Indexing Structures</h4><h5 id="Storing-values-within-the-index"><a href="#Storing-values-within-the-index" class="headerlink" title="Storing values within the index"></a>Storing values within the index</h5><p>In some situations, the extra hop from the index to the heap file is too much of a performance penalty for reads, so it can be desirable to store the indexed row directly within an index. This is known as a <em>clustered index</em>.</p>
<h5 id="Multi-column-indexes"><a href="#Multi-column-indexes" class="headerlink" title="Multi-column indexes"></a>Multi-column indexes</h5><p>…</p>
<h3 id="Transaction-Processing-or-Analytics"><a href="#Transaction-Processing-or-Analytics" class="headerlink" title="Transaction Processing or Analytics?"></a>Transaction Processing or Analytics?</h3><p>online transaction processing(OLTP)<br>online analytic processing (OLAP)</p>
<h4 id="Data-Warehousing"><a href="#Data-Warehousing" class="headerlink" title="Data Warehousing"></a>Data Warehousing</h4><p>The data warehouse con‐ tains a read-only copy of the data in all the various OLTP systems in the company. Data is extracted from OLTP databases (using either a periodic data dump or a con‐ tinuous stream of updates), transformed into an analysis-friendly schema, cleaned up, and then loaded into the data warehouse. This process of getting data into the warehouse is known as Extract–Transform–Load (ETL)</p>
<h5 id="The-divergence-between-OLTP-databases-and-data-warehouses"><a href="#The-divergence-between-OLTP-databases-and-data-warehouses" class="headerlink" title="The divergence between OLTP databases and data warehouses"></a>The divergence between OLTP databases and data warehouses</h5><h4 id="Stars-and-Snowflakes-Schemas-for-Analytics"><a href="#Stars-and-Snowflakes-Schemas-for-Analytics" class="headerlink" title="Stars and Snowflakes: Schemas for Analytics"></a>Stars and Snowflakes: Schemas for Analytics</h4><p>…</p>
<h3 id="Column-Oriented-Storage"><a href="#Column-Oriented-Storage" class="headerlink" title="Column-Oriented Storage"></a>Column-Oriented Storage</h3><p>…</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/note/" rel="tag"># note</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2020/07/24/DDIA2/" rel="prev" title="Note for DDIA in Chapter 2">
      <i class="fa fa-chevron-left"></i> Note for DDIA in Chapter 2
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2020/07/28/DDIA4/" rel="next" title="Note for DDIA in Chapter 4">
      Note for DDIA in Chapter 4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ray Chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/blog/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rezelchen.github.io","root":"/blog/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="PartitioningIn this chapter we will first look at different approaches for partitioning large datasets and observe how the indexing of data interacts with partitioning. We’ll then talk about rebalanci">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for DDIA in Chapter 6">
<meta property="og:url" content="https://rezelchen.github.io/2020/08/12/DDIA6/index.html">
<meta property="og:site_name" content="Ray Chen&#39;s Blog">
<meta property="og:description" content="PartitioningIn this chapter we will first look at different approaches for partitioning large datasets and observe how the indexing of data interacts with partitioning. We’ll then talk about rebalanci">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-12T21:43:00.000Z">
<meta property="article:modified_time" content="2020-08-20T07:33:40.920Z">
<meta property="article:author" content="Ray Chen">
<meta property="article:tag" content="note">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://rezelchen.github.io/2020/08/12/DDIA6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Note for DDIA in Chapter 6 | Ray Chen's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ray Chen's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Partitioning"><span class="nav-number">1.</span> <span class="nav-text">Partitioning</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Partitioning-and-Replication"><span class="nav-number">1.1.</span> <span class="nav-text">Partitioning and Replication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Partitioning-of-Key-Value-Data"><span class="nav-number">1.2.</span> <span class="nav-text">Partitioning of Key-Value Data</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Partitioning-by-Key-Range"><span class="nav-number">1.2.1.</span> <span class="nav-text">Partitioning by Key Range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Partitioning-by-Hash-of-Key"><span class="nav-number">1.2.2.</span> <span class="nav-text">Partitioning by Hash of Key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Skewed-Workloads-and-Relieving-Hot-Spots"><span class="nav-number">1.2.3.</span> <span class="nav-text">Skewed Workloads and Relieving Hot Spots</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Partitioning-and-Secondary-Indexes"><span class="nav-number">1.3.</span> <span class="nav-text">Partitioning and Secondary Indexes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Partitioning-Secondary-Indexes-by-Document"><span class="nav-number">1.3.1.</span> <span class="nav-text">Partitioning Secondary Indexes by Document</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Partitioning-Secondary-Indexes-by-Term"><span class="nav-number">1.3.2.</span> <span class="nav-text">Partitioning Secondary Indexes by Term</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rebalancing-Partitions"><span class="nav-number">1.4.</span> <span class="nav-text">Rebalancing Partitions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Strategies-for-Rebalancing"><span class="nav-number">1.4.1.</span> <span class="nav-text">Strategies for Rebalancing</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#How-not-to-do-it-hash-mod-N"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">How not to do it: hash mod N</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Fixed-number-of-partitions"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Fixed number of partitions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Dynamic-partitioning"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">Dynamic partitioning</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Partitioning-proportionally-to-nodes"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">Partitioning proportionally to nodes</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Operations-Automatic-or-Manual-Rebalancing"><span class="nav-number">1.4.2.</span> <span class="nav-text">Operations: Automatic or Manual Rebalancing</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request-Routing"><span class="nav-number">1.5.</span> <span class="nav-text">Request Routing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Query-Execution"><span class="nav-number">1.5.1.</span> <span class="nav-text">Parallel Query Execution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Summary"><span class="nav-number">1.6.</span> <span class="nav-text">Summary</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ray Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://rezelchen.github.io/2020/08/12/DDIA6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ray Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ray Chen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Note for DDIA in Chapter 6
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-12 21:43:00" itemprop="dateCreated datePublished" datetime="2020-08-12T21:43:00+00:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-20 07:33:40" itemprop="dateModified" datetime="2020-08-20T07:33:40+00:00">2020-08-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Partitioning"><a href="#Partitioning" class="headerlink" title="Partitioning"></a>Partitioning</h2><p>In this chapter we will first look at different approaches for partitioning large datasets and observe how the indexing of data interacts with partitioning. We’ll then talk about rebalancing, which is necessary if you want to add or remove nodes in your cluster. Finally, we’ll get an overview of how databases route requests to the right par‐ titions and execute queries.</p>
<h3 id="Partitioning-and-Replication"><a href="#Partitioning-and-Replication" class="headerlink" title="Partitioning and Replication"></a>Partitioning and Replication</h3><h3 id="Partitioning-of-Key-Value-Data"><a href="#Partitioning-of-Key-Value-Data" class="headerlink" title="Partitioning of Key-Value Data"></a>Partitioning of Key-Value Data</h3><h4 id="Partitioning-by-Key-Range"><a href="#Partitioning-by-Key-Range" class="headerlink" title="Partitioning by Key Range"></a>Partitioning by Key Range</h4><p>This partitioning strategy is used by Bigtable, its open source equivalent HBase, RethinkDB, and MongoDB before version 2.4.</p>
<p>Within each partition, we can keep keys in sorted order. This has the advantage that range scans are easy, and you can treat the key as a concatenated index in order to fetch several related records in one query.</p>
<p>However, the downside of key range partitioning is that certain access patterns can lead to <em>hot spots</em>.</p>
<h4 id="Partitioning-by-Hash-of-Key"><a href="#Partitioning-by-Hash-of-Key" class="headerlink" title="Partitioning by Hash of Key"></a>Partitioning by Hash of Key</h4><p>A good hash function takes skewed data and makes it uniformly distributed. </p>
<p>For partitioning purposes, the hash function need not be cryptographically strong: for example, Cassandra and MongoDB use MD5, and Voldemort uses the Fowler– Noll–Vo function. </p>
<p>Unfortunately however, by using the hash of the key for partitioning we lose a nice property of key-range partitioning: the ability to do efficient range queries. </p>
<h4 id="Skewed-Workloads-and-Relieving-Hot-Spots"><a href="#Skewed-Workloads-and-Relieving-Hot-Spots" class="headerlink" title="Skewed Workloads and Relieving Hot Spots"></a>Skewed Workloads and Relieving Hot Spots</h4><h3 id="Partitioning-and-Secondary-Indexes"><a href="#Partitioning-and-Secondary-Indexes" class="headerlink" title="Partitioning and Secondary Indexes"></a>Partitioning and Secondary Indexes</h3><p>The problem with secondary indexes is that they don’t map neatly to partitions. There are two main approaches to partitioning a database with secondary indexes: document-based partitioning and term-based partitioning.</p>
<h4 id="Partitioning-Secondary-Indexes-by-Document"><a href="#Partitioning-Secondary-Indexes-by-Document" class="headerlink" title="Partitioning Secondary Indexes by Document"></a>Partitioning Secondary Indexes by Document</h4><p>In this indexing approach, each partition is completely separate: each partition main‐ tains its own secondary indexes, covering only the documents in that partition. For that reason, a document-partitioned index is also known as a local index (as opposed to a global index, described in the next section).</p>
<p>You need to send the query to all partitions, and combine all the results you get back.</p>
<p>This approach to querying a partitioned database is sometimes known as <em>scatter/ gather</em>, and it can make read queries on secondary indexes quite expensive. </p>
<h4 id="Partitioning-Secondary-Indexes-by-Term"><a href="#Partitioning-Secondary-Indexes-by-Term" class="headerlink" title="Partitioning Secondary Indexes by Term"></a>Partitioning Secondary Indexes by Term</h4><p>A global index must also be partitioned, but it can be partitioned differently from the primary key index.</p>
<p>We call this kind of index <em>term-partitioned</em>, because the term we’re looking for determines the partition of the index. </p>
<p>The advantage of a global (term-partitioned) index over a document-partitioned index is that it can make reads more efficient: rather than doing scatter/gather over all partitions, a client only needs to make a request to the partition containing the term that it wants. However, the downside of a global index is that writes are slower and more complicated, because a write to a single document may now affect multiple partitions of the index (every term in the document might be on a different partition, on a different node).</p>
<p>In practice, updates to global secondary indexes are often asynchronous (that is, if you read the index shortly after a write, the change you just made may not yet be reflected in the index).</p>
<h3 id="Rebalancing-Partitions"><a href="#Rebalancing-Partitions" class="headerlink" title="Rebalancing Partitions"></a>Rebalancing Partitions</h3><p>The process of moving load from one node in the cluster to another is called <em>rebalancing</em>.</p>
<p>No matter which partitioning scheme is used, rebalancing is usually expected to meet some minimum requirements:</p>
<ul>
<li><p>After rebalancing, the load (data storage, read and write requests) should be shared fairly between the nodes in the cluster.</p>
</li>
<li><p>While rebalancing is happening, the database should continue accepting reads and writes.</p>
</li>
<li><p>No more data than necessary should be moved between nodes, to make rebalancing fast and to minimize the network and disk I/O load.</p>
</li>
</ul>
<h4 id="Strategies-for-Rebalancing"><a href="#Strategies-for-Rebalancing" class="headerlink" title="Strategies for Rebalancing"></a>Strategies for Rebalancing</h4><h5 id="How-not-to-do-it-hash-mod-N"><a href="#How-not-to-do-it-hash-mod-N" class="headerlink" title="How not to do it: hash mod N"></a>How not to do it: hash mod N</h5><p>When partitioning by the hash of a key, we said earlier that it’s best to divide the possible hashes into ranges and assign each range to a partition (e.g., assign key to partition 0 if 0 ≤ hash(key) &lt; b0, to partition 1 if b0 ≤ hash(key) &lt; b1, etc.).</p>
<p>The problem with the mod N approach is that if the number of nodes N changes, most of the keys will need to be moved from one node to another. </p>
<h5 id="Fixed-number-of-partitions"><a href="#Fixed-number-of-partitions" class="headerlink" title="Fixed number of partitions"></a>Fixed number of partitions</h5><p>Fortunately, there is a fairly simple solution: create many more partitions than there are nodes, and assign several partitions to each node.  For example, a database running on a cluster of 10 nodes may be split into 1,000 partitions from the outset so that approximately 100 partitions are assigned to each node.</p>
<p>Now, if a node is added to the cluster, the new node can <em>steal</em> a few partitions from every existing node until partitions are fairly distributed once again. If a node is removed from the cluster, the same happens in reverse.</p>
<p>In this configuration, the number of partitions is usually fixed when the database is first set up and not changed afterward. </p>
<h5 id="Dynamic-partitioning"><a href="#Dynamic-partitioning" class="headerlink" title="Dynamic partitioning"></a>Dynamic partitioning</h5><p>For databases that use key range partitioning, a fixed number of partitions with fixed boundaries would be very incon‐ venient: if you got the boundaries wrong, you could end up with all of the data in one partition and all of the other partitions empty.</p>
<p>When a partition grows to exceed a configured size (on HBase, the default is 10 GB), it is split into two partitions so that approximately half of the data ends up on each side of the split. Conversely, if lots of data is deleted and a partition shrinks below some threshold, it can be merged with an adjacent par‐ tition. This process is similar to what happens at the top level of a B-tree.</p>
<p>Each partition is assigned to one node, and each node can handle multiple partitions, like in the case of a fixed number of partitions. After a large partition has been split, one of its two halves can be transferred to another node in order to balance the load.</p>
<p>An advantage of dynamic partitioning is that the number of partitions adapts to the total data volume. </p>
<p>However, a caveat is that an empty database starts off with a single partition, since there is no a priori information about where to draw the partition boundaries. While the dataset is small—until it hits the point at which the first partition is split—all writes have to be processed by a single node while the other nodes sit idle. </p>
<p>Dynamic partitioning is not only suitable for key range–partitioned data, but can equally well be used with hash-partitioned data. </p>
<h5 id="Partitioning-proportionally-to-nodes"><a href="#Partitioning-proportionally-to-nodes" class="headerlink" title="Partitioning proportionally to nodes"></a>Partitioning proportionally to nodes</h5><p>With dynamic partitioning, the number of partitions is proportional to the size of the dataset, since the splitting and merging processes keep the size of each partition between some fixed minimum and maximum. On the other hand, with a fixed number of partitions, the size of each partition is proportional to the size of the dataset. In both of these cases, the number of partitions is independent of the number of nodes.</p>
<p>A third option, used by Cassandra and Ketama, is to make the number of partitions proportional to the number of nodes—in other words, to have a fixed number of partitions <em>per node</em>.</p>
<p>When a new node joins the cluster, it randomly chooses a fixed number of existing partitions to split, and then takes ownership of one half of each of those split partitions while leaving the other half of each partition in place. </p>
<p>Picking partition boundaries randomly requires that hash-based partitioning is used. ndeed, this approach corresponds most closely to the original definition of consistent hashing. Newer hash func‐ tions can achieve a similar effect with lower metadata overhead.</p>
<h4 id="Operations-Automatic-or-Manual-Rebalancing"><a href="#Operations-Automatic-or-Manual-Rebalancing" class="headerlink" title="Operations: Automatic or Manual Rebalancing"></a>Operations: Automatic or Manual Rebalancing</h4><h3 id="Request-Routing"><a href="#Request-Routing" class="headerlink" title="Request Routing"></a>Request Routing</h3><p>Somebody needs to stay on top of those changes in order to answer the question: if I want to read or write the key “foo”, which IP address and port number do I need to connect to?</p>
<p>This is an instance of a more general problem called <em>service discovery</em>, which isn’t limited to just databases. </p>
<p>On a high level, there are a few different approaches to this problem:</p>
<ol>
<li><p>Allow clients to contact any node (e.g., via a round-robin load balancer). If that node coincidentally owns the partition to which the request applies, it can handle the request directly; otherwise, it forwards the request to the appropriate node, receives the reply, and passes the reply along to the client.</p>
</li>
<li><p>Send all requests from clients to a routing tier first, which determines the node that should handle each request and forwards it accordingly. This routing tier does not itself handle any requests; it only acts as a partition-aware load balancer.</p>
</li>
<li><p>Require that clients be aware of the partitioning and the assignment of partitions to nodes. In this case, a client can connect directly to the appropriate node, without any intermediary.</p>
</li>
</ol>
<p>In all cases, the key problem is: how does the component making the routing decision (which may be one of the nodes, or the routing tier, or the client) learn about changes in the assignment of partitions to nodes?</p>
<p>This is a challenging problem, because it is important that all participants agree— otherwise requests would be sent to the wrong nodes and not handled correctly.</p>
<p>Many distributed data systems rely on a separate coordination service such as ZooKeeper to keep track of this cluster metadata. Each node registers itself in ZooKeeper, and ZooKeeper maintains the authoritative mapping of partitions to nodes. Other actors, such as the routing tier or the partitioning-aware client, can subscribe to this information in ZooKeeper. Whenever a partition changes ownership, or a node is added or removed, ZooKeeper notifies the routing tier so that it can keep its routing information up to date.</p>
<p>Cassandra and Riak take a different approach: they use a gossip protocol among the nodes to disseminate any changes in cluster state. Requests can be sent to any node, and that node forwards them to the appropriate node for the requested partition.</p>
<h4 id="Parallel-Query-Execution"><a href="#Parallel-Query-Execution" class="headerlink" title="Parallel Query Execution"></a>Parallel Query Execution</h4><p>So far we have focused on very simple queries that read or write a single key.</p>
<p>However, <em>massively parallel processing</em> (MPP) relational database products, often used for analytics, are much more sophisticated in the types of queries they support. The MPP query optimizer breaks this complex query into a num‐ ber of execution stages and partitions, many of which can be executed in parallel on different nodes of the database cluster. </p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>…</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/note/" rel="tag"># note</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2020/08/08/DDIA5/" rel="prev" title="Note for DDIA in Chapter 5">
      <i class="fa fa-chevron-left"></i> Note for DDIA in Chapter 5
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2020/08/13/DDIA7/" rel="next" title="Note for DDIA in Chapter 7">
      Note for DDIA in Chapter 7 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ray Chen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>


  















  

  

</body>
</html>
